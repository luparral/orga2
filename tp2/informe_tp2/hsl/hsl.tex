\section{HSL}
\subsection{Introducción}
\textit{HSL} es un filtro que consta de tres etapas:
\begin{enumerate}
\item \textbf{RGBtoHSL:} consiste en un cambio del espacio de color de los pixeles, desde RGB a HSL. 
\item \textbf{Suma:} se procesan los píxeles sumándole valores pasados por parámetro a cada una de las componentes.
\item \textbf{RGBtoHSL:} se realiza la operación inversa a la de la primera etapa, es decir, el pasaje del espacio HSL a RGB.
\end{enumerate}

El pseudocódigo de cada una de estas etapas es descripto en el enunciado del TP.

\subsection{Implementación 1}
En esta sección se pide realizar una implementación de la etapa de \textit{Suma} en ASM y desde la misma llamar a las funciones en C para convertir entre RGB y HSL.\\
Como las funciones \textit{RGBtoHSL} y \textit{hslTOrgb} procesan de a un pixel, es necesario iterar sobre cada pixel de la imagen para para ir procesándolos.\\

De esta forma, los pasos que se realizan en una iteración del ciclo son los siguientes:

\begin{enumerate}

\item Tomar un pixel de la imagen.
\item Llamar a la función \textit{RGBtoHSL} de C.
\item Con el pixel ya transformado al espacio HSL, hay que realizar la operación de suma en sí. Esta se realiza de la siguiente manera:\\

\textbf{Pseudocódigo de Suma}
\begin{verbatim}
	if( h+HH >= 360 ) h = h + HH - 360
	else if( h+HH < 0 ) h = h + HH + 360
	else
	    h = h + HH
	if( s+SS >= 1 ) s = 1
	else if( s+SS < 0 ) s = 0
	else
	    s = s + SS
	if( l+LL >= 1 ) l = 1
	else if( l+LL < 0 ) l = 0
	else
	    l = l + LL         
\end{verbatim}
Para poder realizar estas operaciones, necesitamos armar un registro de que contenga cuatro dwords que tengan la siguiente forma:

\begin{tabular}{| g | g | g | g |} %tabla color orange
\hline
$l+LL$ & $s+SS$ & $h+HH$ & $aa$ \\ 
\hline
\end{tabular}

Donde \textit{h}, \textit{s} y \textit{l} son las componentes del pixel HSL y \textit{HH}, \textit{SS} y \textit{LL} los valores pasados como parámetros. El \textit{aa} es el dword correspondiente al alfa, que va a quedar sin modificaciones.

Para realizar el registro mostrado anteriormente realizamos las siguientes operaciones:

\begin{lstlisting}
movss xmm1, [posicion_de_memoria_donde_esta_LL]	;xmm1 = |00|00|00|LL|
pslldq xmm1, 12			;xmm1 = |00|00|LL|00| - shift a izquierda
movss xmm2, [posicion_de_memoria_donde_esta_SS]	;xmm1 = |00|00|LL|SS|
pslldq xmm2, 8			;xmm1 = |00|LL|SS|00| - shift a izquierda
movss xmm3, [posicion_de_memoria_donde_esta_HH]	;xmm1 = |00|LL|SS|HH|
pslldq xmm3, 4			;xmm1 = |LL|SS|HH|aa| - shift a izquierda
\end{lstlisting}
Y luego, sumamos este registro al registro en donde tenemos a los tres componentes HSL de pixel.\\ Llamaremos a este registro \textit{origen} para claridad.

Estas operaciones debemos realizarlas en cada iteración del ciclo, porque tras el llamado a funciones de C, la convención no nos asegura que los registros XMM mantendrán sus valores.\\
Por último en este paso, vamos a armar las máscaras que necesitamos para realizar las operaciones del pseudocódigo que mostramos al principio de este punto.\\
Realizamos los siguientes defines:\\
\begin{verbatim}
comparar: dd 0.0, 360.0, 1.0, 1.0
vuelta_atras: dd 0.0, -360.0, 1.0, 1.0
vuelta_adelante: dd	0.0, 360.0, 0.0, 0.0         
\end{verbatim}
Y preparamos los siguientes registros:
\begin{lstlisting}
;traigo mascaras
	movups xmm10, [comparar]
	pxor xmm11, xmm11	;llamaremos ceros a xmm11
	movups xmm2, [vuelta_atras]
	movups xmm3, [vuelta_adelante]

;preparo datos con mascaras
	pxor xmm5, xmm5
	movlhps xmm5, xmm0	;xmm5 = |h+HH|aa|00|00|
	psrldq xmm5, 8			;xmm5 = |00|00|h+HH|aa|
	movups xmm6, xmm5		;xmm6 = |00|00|h+HH|aa|
	addps xmm5, xmm2		;xmm5 = |1|1|h+HH-360|aa| - llamaremos resultadoTRUEif a xmm5
	addps xmm6, xmm3		;xmm6 = |0|0|h+HH+360|aa| - llamaremos resultadoFALSEif a xmm6

\end{lstlisting}

\item En el punto anterior preparamos todos los registros necesarios para finalmente en este punto, realizar la lógica de suma según el pseudocódigo visto.\\
Como las componentes están enpaquetadas, debemos realizar las comparaciones simultáneamente. Para esto nos valemos de las máscaras que realizamos anteriormente. Para claridad al mostrar al código, reemplazaremos los registros efectivamente usados por los nombres de las etiquetas definidas en los defines y en los comentarios hechos anteriormente, donde armamos las máscaras necesarias.

\begin{lstlisting}
//xmm0, xmm1, xmm7 y xmm8 son copias de origen.
;if h+HH>=360 || s+SS>1 || l+LL>1
	cmpps xmm0, comparar, 5	;5 = greater equal
	pand xmm0, resultadoTRUEif

;if 0<=h+HH<360 || 0<=s+SS<1 || 0<=l+LL<1
	cmpps xmm7, comparar, 1	;1 = less than
	cmpps xmm8, ceros, 5	;5 = greater equal - ceros es un registro con ceros hecho con un pxor entre un registro XMM y si mismo.
	pand xmm7, xmm8
	pand xmm7, xmm1

;if h+HH<0 || s+SS<0 || l+LL<0
	cmpps xmm1,	xmm11, 1	;1 = less than
	pand xmm1, resultadoFALSEif

;sumo todos los valores con las mascaras aplicadas
	por xmm0, xmm7
	por xmm0, xmm1
\end{lstlisting}
En este punto tenemos en xmm0 el resultado para cada componente tras realizar las comparaciones indicadas por el pseudocódigo y asignar el valor indicado en cada caso. 
\item Con el pixel ya modificado en todas sus componentes, ahora ya podemos pasarselo a la función \textbf{hslTOrgb} para volver a pasar al espacio RGB.
\item Finalmente, avanzamos un pixel y volvemos a iterar.

\end{enumerate}

\subsection{Implementación 2}
La consigna en esta implementación es desarrollar todas las etapas del filtro en ASM.