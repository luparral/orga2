\section{Introducción}
En este trabajo práctico se busca experimentar con el procesamiento con instrucciones SIMD que operan con múltiples datos simultáneamente.\\ 
Con este fin, desarrollamos distintas implementaciones de los filtros Blur, Merge y HSL sobre imágenes y evaluamos su rendimiento.\\
\subsection{Sobre la experimentación}
Realizamos las experimentaciones para los tres filtros con sus respectivas implementaciones de la manera que se detalla a continuación:\\
Para realizar casos de tests exhaustivos, utilizamos imágenes de distintos tamaños y tipos. Es decir, tomamos imágenes de colores constantes (totalmente blancas, azules, verdes, rojas y negras), imágenes que tienen una predominancia principal de cada uno de esos colores y por último imágenes mixtas (muchos colores, donde ninguno de ellos es predominante).\\
Cada una de estas imágenes las procesamos en los tamaños 40x40 (1600 píxeles), 300x300 (90000 píxeles) y 600x600 (360000 píxeles), ya que nos pareció razonable mostrar la performance de las distintas implementaciones de los filtros variando su tamaño.\\
Para cada filtro, cada implementación, cada tamaño y cada imágen, calculamos la cantidad de ciclos de clock que transcurren en las instrucciones que procesan la imagen. Desde ya, que no se toma en cuenta el proceso en el que se carga la imagen, se leen los headers, se hace una copia de la imagen para procesar, etc, sino que solamente se mide el tiempo en el que el filtro en sí comienza a ejecutar, que es lo que varía entre las 3 implementaciones y que es lo que interesa medir.\\
Para medir los ciclos de clock usamos las funciones provistas por la cátedra en el archivo rdtsc.h.\\ 

Teniendo en cuenta que existen problemáticas al momento de conocer el tiempo de ejecución real de los programas, ya que la ejecución puede ser interrumpida por el scheduler para realizar un cambio de contexto o bien que los procesadores varían la frecuencia de reloj, ideamos la siguiente metodología para medir la cantidad de ciclos de clock de nuestras implementaciones:\\
Para cada test, realizamos 100 repeticiones, tomando el promedio de los resultados obtenidos; luego, descartamos el 10\% de los peores casos para eliminar así en los que fue más probable que el procesador haya cambiado de contexto. Una vez hecho esto, calculamos el desvío estándar del 90\% de los casos restantes, y de esta forma, obtuvimos un resultado promedio tal que sumando y restando el desvío estándar, se obtiene el resultado esperado en mejor y peor caso. Así mismo, el desvío estándar también nos sirve como indicador de qué tan precisas fueron las mediciones.\\
Además, por último, compilamos las implementaciones de C provistas por la cátedra con el parámetro de compilación -O3, que asegura la versión más optimizada del de ensamblado del código, para poder acercarnos a la mejor ejecución posible de dichas implementaciones.\\

%TODO: Calcular o chamuyar el desvío estándar en las mediciones y hablar un poco de eso luego.
\textbf{Características técnicas de la computadora en la que se realizaron las experimentaciones:}
Las experimentaciones fueron realizadas, siempre sobre la misma computadora, para obtener resultados comparables, tratando de tenerla en el estado más estable posible para minimizar la posibilidad de cambio de contexto del procesador.\\
Sin más, la computadora cuenta con las siguientes características técnicas:\\

\textit{Memoria RAM:} 7,7 GiB\\
\textit{Procesador:} Intel Core i7-3630QM CPU \@ 2.40GHz x 8\\
\textit{Sistema operativo:} Ubuntu 14.04 64 bits\\

Para experimentar acerca de si variaba el rendimiento de una implementación en función del tipo de imagen testeado elaboramos la siguiente estrategia. Agrupamos por color los distintos tipos de imágenes con los que contábamos como casos de prueba, descritos en la introducción del apartado de experimentación, y tomamos el promedio de tiempos de ejecución (tomando el 10\% peor como outliers) para cada subgrupo.\\ 
Luego, tomando los promedios de cada tipo de imagen como el representante de dicho tipo, calculamos un promedio general de todos los subgrupos, obteniendo de esta forma el tiempo promedio demorado por la implementación para un tamaño dado.\\
También calculamos el desvío estándar entre todos los representantes de subgrupos, y una vez calculado el desvío estándar, lo dividimos por el promedio y multiplicamos por 100 para tener un “porcentaje de desviación”. De esta forma, un porcentaje elevado significa que los representantes de cada tipo de imagen difieren significativamente, mientras que un porcentaje pequeño, que todos los representantes estan cercanos al promedio y por lo tanto, las mediciones dentro de todos los tipos se mantiene estable.\\

Por último, tomamos como decisión para una mayor claridad en los gráficos, el utilizar escala logarítmica para representar los ciclos de clock, ya que de no hacerlo, se perdía claridad y representatividad en los mismos cuando el tiempo de ejecución. De cualquier manera, en cada gráfico figurará qué tipo de escala está utilizando, y cualquier otra información relevante.\\\\\\\\\\\\\\\\\\

\begin{figure}[ht]
\centering
\includegraphics[width=90mm]{introduccion/lena_instagram.jpg}
%\caption{A simple caption \label{overflow}}
\end{figure}
