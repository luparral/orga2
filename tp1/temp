
	; ; bool menorEstudiante( estudiante *e1, estudiante *e2 ){
	; menorEstudiante:
	; 	;rdi e1
	; 	;rsi e2
	; 	push rbp
	; 	mov rbp, rsp
	; 	push rbx
	; 	push r12
	; 	push r13
	; 	sub rsp, 8

	; 	mov r12, rdi
	; 	mov r13, rsi

	; 	call string_menor
	; 	cmp al, TRUE
	; 	je esMenor

	; 	mov rdi, r12
	; 	mov rsi, r13
	; 	call string_iguales
	; 	cmp al, TRUE
	; 	je sonIgualesLosEstudiantes
	; 	jmp noEraMenor ;completar

	; sonIgualesLosEstudiantes:
	; 	mov rbx, [r12 + OFFSET_EDAD] 
	; 	cmp rbx, [r13 + OFFSET_EDAD]
	; 	jle esMenor
	; 	jmp noEraMenor

	; esMenor:
	; 	mov al, TRUE
	; 	jmp terminar

	; noEraMenor:
	; 	mov al, FALSE
	; 	jmp terminar

	; terminar:
	; 	add rsp, 8
	; 	pop r13
	; 	pop r12
	; 	pop rbx
	; 	pop rbp
	; 	ret 

	; ; void estudianteConFormato( estudiante *e, tipoFuncionModificarString f )
	; estudianteConFormato:
	; 	; COMPLETAR AQUI EL CODIGO
	
	; ; void estudianteImprimir( estudiante *e, FILE *file )
	; estudianteImprimir:
	; 	; COMPLETAR AQUI EL CODIGO


;/** FUNCIONES DE ALTALISTA Y NODO     >> PUEDEN CREAR LAS FUNCIONES AUXILIARES QUE CREAN CONVENIENTES
;--------------------------------------------------------------------------------------------------------

	; nodo *nodoCrear( void *dato )
	; nodoCrear:
	; 	; dato esta en rdi
	; 	push rbp
	; 	mov rbp, rsp
	; 	push r12
	; 	sub rsp, 8

	; 	mov r12, rdi ; guardo el dato en r12
	; 	mov rdi, NODO_SIZE
	; 	call malloc ;en rax queda el puntero al nuevo nodo
	; 	mov qword [rax + OFFSET_DATO], r12
	; 	mov qword [rax + OFFSET_ANTERIOR], NULL
	; 	mov qword [rax + OFFSET_SIGUIENTE], NULL
		
	; 	add rsp, 8
	; 	pop r12
	; 	pop rbp
	; 	ret

	; void nodoBorrar( nodo *n, tipoFuncionBorrarDato f )
	; nodoBorrar:
	; 	;rdi = nodo
	; 	push rbp
	; 	mov rbp, rsp
	; 	push r12
	; 	sub rsp, 8

	; 	mov r12, rdi
	; 	mov qword [r12 + OFFSET_SIGUIENTE], NULL
	; 	mov qword [r12 + OFFSET_ANTERIOR], NULL
	; 	mov rdi, [r12+OFFSET_DATO]
	; 	call estudianteBorrar
	; 	mov rdi, r12
	; 	call free ;borro el nodo

	; 	add rsp, 8
	; 	pop r12
	; 	pop rbp
	; 	ret

	; altaLista *altaListaCrear( void )
	; altaListaCrear:
	; 	push rbp
	; 	mov rbp, rsp
		
	; 	mov rdi, ALTALISTA_SIZE
	; 	call malloc
	; 	mov qword [rax + OFFSET_PRIMERO], NULL
	; 	mov qword [rax + OFFSET_ULTIMO], NULL
		
	; 	pop rbp
	; 	ret

	; ; void altaListaBorrar( altaLista *l, tipoFuncionBorrarDato f )
	; altaListaBorrar:
	; 	;rdi = l

	; 	push rbp
	; 	mov rbp, rsp
	; 	push r12
	; 	push r13
	; 	push r14
	; 	push r15
	; 	push rbx
	; 	sub rbp, 8

	; 	mov r12, rdi
	; 	mov r13, [r12 + OFFSET_PRIMERO]
	; 	cmp r13, NULL 
	; 	jne hayUnElemento ;l->primero != NULL
	; 	jmp finBorrar


	; hayUnElemento:
	; 	;r14 rcx nodoActual = l->primero
	; 	;r15 rdx nodoSiguiente = l->primero->siguiente
	; 	;rbx r8 nodoABorrar = nodoActual
	; 	mov r14, [r12 + OFFSET_PRIMERO]
	; 	mov r15, [r14 + OFFSET_SIGUIENTE] ;esto esta bien para apuntar al siguiente?
	; 	mov rbx, r14
	; 	cmp r15, NULL
	; 	jne hayOtroElemento
	; 	jmp borrarNodo

	; hayOtroElemento:
	; 	;r14 rcx : nodoActual = nodoSiguiente
	; 	;r15 rdx : nodoSiguiente = nodoSiguiente->siguiente
	; 	;rbx r8: nodoABorrar = nodoActual
	; 	mov r14, r15
	; 	mov r15, [r14 + OFFSET_SIGUIENTE] ;esto esta bien?
	; 	mov rdi, rbx
	; 	call nodoBorrar ;supuestamente se va a borrar lo que esta en rdi, que es r8
	; 	mov rbx, r14
	; 	cmp r15, NULL
	; 	jne hayOtroElemento
	; 	jmp borrarNodo

	; borrarNodo:

	; 	mov rdi, r14
	; 	call nodoBorrar ;supuestamente se va a borrar lo que esta en rdi, que es rcx
	; 	jmp finBorrar

	; finBorrar:
	; 	mov qword [r9 + OFFSET_PRIMERO], NULL
	; 	mov qword [r9 + OFFSET_ULTIMO], NULL
	; 	call free
		
	; 	add rbp, 8
	; 	pop rbx
	; 	pop r15
	; 	pop r14
	; 	pop r13
	; 	pop r12
	; 	pop rbp
	; 	ret

	; void altaListaImprimir( altaLista *l, char *archivo, tipoFuncionImprimirDato f )
	altaListaImprimir:
		; COMPLETAR AQUI EL CODIGO


;/** FUNCIONES AVANZADAS     >> PUEDEN CREAR LAS FUNCIONES AUXILIARES QUE CREAN CONVENIENTES
;----------------------------------------------------------------------------------------------

	; ; float edadMedia( altaLista *l )
	; edadMedia:
	; 	;rdi = l
	; 	push rbp
	; 	mov rbp, rsp
	; 	push r12
	; 	push r13
	; 	push r14
	; 	sub rbp, 8

	; 	mov r12, rdi	
	; 	call cantidadDeNodos
	; 	mov r13, rax ;guardo en rsi la cantidadEstudiantes
		
	; 	xor rax, rax

	; 	mov rdi, r12
	; 	call sumaEdades
	; 	mov r14, rax
	; 	cvtsi2ss xmm0, r13
	; 	cvtsi2ss xmm1, r14
	; 	divss xmm0, xmm2
		
	; 	add rbp, 8
	; 	pop r14
	; 	pop r13
	; 	pop r12
	; 	pop rbp
	; 	ret

	; void insertarOrdenado( altaLista *l, void *dato, tipoFuncionCompararDato f )
	insertarOrdenado:
		; COMPLETAR AQUI EL CODIGO

	; void filtrarAltaLista( altaLista *l, tipoFuncionCompararDato f, void *datoCmp )
	filtrarAltaLista:
		; COMPLETAR AQUI EL CODIGO

	; ;char *string_copiar( char *s );
	; string_copiar:
	; 	;rdi = string a copiar
	; 	push rbp
	; 	mov rbp, rsp
	; 	push r12
	; 	push r13
	; 	push r14
	; 	sub rbp, 8

	; 	mov r12, rdi ; en r12 queda el string a copiar
	; 	call string_longitud ;longitud del string
	; 	;rax <- |string|
	; 	inc rax ;+1 para el caracter del final
	; 	;en rax esta la longitud del string +1
	; 	mov rdi, rax
	; 	call malloc
	; 	;rax <- puntero al primero
	; 	mov r13, rax ;copio el puntero al string nuevo de rax a r13
	; 	xor r14, r14 ;i = 0
	; 	jmp cicloCopiar

	; cicloCopiar:
	; 	;en r12 tengo el string original
	; 	;en r13 tengo el puntero de la direccion nueva
	; 	cmp qword [r12+r14], 0 ;llegue al final del string que estoy copiando
	; 	je finCopiar
	; 	add r13, r14
	; 	mov r13, [r12 + r14]		
	; 	inc r14
	; 	jmp cicloCopiar

	; finCopiar:
	; 	add rbp, 8
	; 	pop r14
	; 	pop r13
	; 	pop r12
	; 	ret
	
	; ;unsigned char string_longitud( char *s )s
	; string_longitud:
	; 	;s esta en rdi
	; 	push rbp
	; 	mov rbp, rsp
	; 	push r12
	; 	push r13
	; 	push r14
	; 	sub rbp, 8

	; 	mov r12, rdi
	; 	xor r13, r13 ;i = 0
	; 	jmp cicloStringLongitud

	; cicloStringLongitud:
	; 	mov r14, [r12+r13];supuestamente voy poniendo cada caracter en rdx
	; 	inc r13
	; 	cmp r14, 0 ;chequear si llegue a cero?
	; 	jae finStringLongitud
	; 	jmp cicloStringLongitud

	; finStringLongitud:
	; 	mov rax, r13
	; 	add rbp, 8
	; 	pop r14
	; 	pop r13
	; 	pop r12
	; 	pop rbp
	; 	ret

	
	; cmp a, b = a - b
	; si a - b = mayor que 0 => a > b
	;si a - b = menor que 0 => a < b
	; ;bool string_menor(char *s1, char *s2){ //s1 < s2
	; string_menor:
	; 	;rdi: s1
	; 	;rsi: s2

	; 	push rbp
	; 	mov rbp, rsp

	; 	mov r12, rdi ;r12 = s1
	; 	mov r13, rsi ;r13 = s2
	; 	call string_iguales
	; 	cmp rax, 0

	; 	je sonIgualesStringMenor
		
	; 	xor r14, r14; i = 0
	; 	mov al, FALSE; pongo al en false
	; 	jmp cicloStringMenor

	; cicloStringMenor:
	; 	cmp qword [r12 + r14], 0 ;(s1[i]!=0)
	; 	je finStringMenor
	; 	cmp qword [r13 + r14], 0 ; s2[i]==0
	; 	je finStringMenor
	; 	mov r15, [r12+r14]
	; 	cmp r15, [r13+r14]; (s1[i]>s2[i])
	; 	jg s1MayorAs2
	; 	mov rbx, [r12+r14]
	; 	cmp rbx, [r13+r14]; (s1[i]<s2[i])
	; 	jl s1MenorAs2
	; 	mov al, TRUE
	; 	inc r14
	; 	jmp cicloStringMenor

	; s1MenorAs2:
	; 	mov al, TRUE
	; 	jmp finStringMenor
 	
	; s1MayorAs2:
	; 	mov al, FALSE		
	; 	jmp finStringMenor

	; finStringMenor:
	; 	pop rbp
	; 	ret ;aca estoy devolviendo al?

	; sonIgualesStringMenor:
	; 	mov al, FALSE
	; 	jmp finStringMenor


	;otras funciones auxiliares hechas por menorEstudiante
	;int cantidadDeNodos (altaLista* l)
	; cantidadDeNodos:
	; 	;rdi = l
	; 	push rbp
	; 	mov rbp, rsp

	; 	xor r13, r13 ;limpio r13 cantidadDeEstudiantes = 0
	; 	mov r14, [rdi + OFFSET_PRIMERO]	
	; 	cmp r14, 0
	; 	je finCantidadDeNodos
	; 	jmp cicloCantidadDeNodos
	
	; cicloCantidadDeNodos:
	; 	cmp r14, 0 ; (nodoActual != NULL)
	; 	je finCantidadDeNodos
	; 	inc r13 ; cantidadEstudiantes++
	; 	mov r14, [r14 + OFFSET_SIGUIENTE]
	; 	jmp cicloCantidadDeNodos

	; finCantidadDeNodos:
	; 	mov rax, r13
	; 	pop rbp
	; 	ret

	; ;int sumaEdades (altaLista* l)
	; sumaEdades:
	; ;rdi = l

	; 	push rbp
	; 	push rbp, rsp

	; 	xor r8, r8 ;limpio r8 suma = 0
	; 	mov rsi, [rdi+OFFSET_PRIMERO]; nodoActual
	; 	jmp cicloSumaEdades

	; cicloSumaEdades:
	; 	cmp rsi, 0; (l->primero != NULL)
	; 	je finSumaEdades
	; 	xor rdx, rdx; limpio rdx
	; 	mov rdx, [rsi+OFFSET_DATO]
	; 	mov rdx, [rdx+OFFSET_EDAD] ;((estudiante*)nodoActual->dato)->edad;
	; 	add r8, rdx
	; 	mov rsi, [rsi + OFFSET_SIGUIENTE] ;nodoActual = nodoActual->siguiente;
	; 	jmp cicloSumaEdades
		
	; finSumaEdades:
	; 	mov rax, r8
	; 	pop rbp
	; 	ret
